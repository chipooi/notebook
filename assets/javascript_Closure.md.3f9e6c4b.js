import{o as n,c as s,a}from"./app.6ae31f14.js";const p='{"title":"什么是闭包？","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是闭包？","slug":"什么是闭包？"},{"level":2,"title":"闭包产生的原因","slug":"闭包产生的原因"},{"level":2,"title":"闭包有哪些表现形式？","slug":"闭包有哪些表现形式？"},{"level":2,"title":"一道经典题目","slug":"一道经典题目"}],"relativePath":"javascript/Closure.md","lastUpdated":1622120774662}',t={},o=a('<h2 id="什么是闭包？"><a class="header-anchor" href="#什么是闭包？" aria-hidden="true">#</a> 什么是闭包？</h2><p>闭包是指有权访问另外一个函数作用域中变量的函数。 MDN 上对闭包的定义：闭包是指那些可以访问<code>自由变量</code>的函数。(自由变量是指在函数中使用，但是既不是函数的参数 arguments 也不是函数局部变量的变量)</p><h2 id="闭包产生的原因"><a class="header-anchor" href="#闭包产生的原因" aria-hidden="true">#</a> 闭包产生的原因</h2><p>要理解闭包首先要连接作用域链，在 ES5 中只存在两种作用域：全局作用域，函数作用域。ES6 后引入了块级作用域的概念。 当访问一个变量时，解释器会首先在当前作用域查找该变量的标识符，如果当前作用域中查找不到，就会到上层作用域中查找，逐层向上查找，直到找到该变量对应的标识符或者到达最外层的全局作用域还无法找到时抛出错误。 还有一个需要注意的点是：javascript 中的作用域遵循的是<code>词法作用域模型（也叫静态作用域）</code>，所以一般情况下，作用域在书写的时候就已经确定了。为什么这里说的是一般情况下呢，因为有两个特殊情况：eval 和 with。eval 和 with 会修改作用域</p><p>几个 🌰：</p><div class="language-js"><pre><code><span class="token comment">// 全局作用域中定义了变量a:1</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//  f1函数作用域中定义了一个变量a:2</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//  f2函数作用域中定义了一个变量a:3</span>\n    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n    <span class="token comment">// 因为当前函数作用域中可以找到变量a，所以不需要到上层作用域中去查找，直接输出当前作用域中a的值3</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// f1函数作用域中定义了变量a:2</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// f2函数作用域中没有定义变量a，通过作用域链查找上层作用域，找到a为2,所以这里的a就是2</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> f2<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><div class="language-js"><pre><code><span class="token comment">// 定义一个全局变量f2</span>\n<span class="token keyword">var</span> f2<span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 定义一个函数作用域变量a</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n  <span class="token comment">//   给变量f2赋值，赋值后f2拥有了全局作用域、f1函数作用域以及自己本身的函数作用域等作用域的访问权限</span>\n  <span class="token function-variable function">f2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 输出变量a，当前函数作用域中没有变量a，所以去到上层作用域f1中查找，找到了直接输出1，不需要再到上层去查找了</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="闭包有哪些表现形式？"><a class="header-anchor" href="#闭包有哪些表现形式？" aria-hidden="true">#</a> 闭包有哪些表现形式？</h2><ol><li>返回一个函数，如上面的几个 🌰；</li><li>作为函数参数返回</li></ol><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 当前函数作用域没有定义变量a，去上层作用域找到了变量a，直接输出变量a的值2</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">bar</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查看[[Scopes]]可以看到作用域链</span>\n  <span class="token comment">// 这就是闭包</span>\n  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n</code></pre></div><ol start="3"><li>在定时器、事件监听、Ajax 请求、跨窗口通信、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是闭包</li></ol><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token comment">// 定时器</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 可以访问当前作用域以及全局作用域</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 事件监听</span>\ndocument<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 可以访问当前作用域以及全局作用域</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><ol start="4"><li>IIFE(immediately invoked function expression，立即执行函数表达式)创建闭包</li></ol><div class="language-js"><pre><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 保存了全局作用域和当前函数作用域，所以可以访问全局作用域中的变量</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="一道经典题目"><a class="header-anchor" href="#一道经典题目" aria-hidden="true">#</a> 一道经典题目</h2><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面的代码输出了<code>5</code>个<code>5</code>，为什么会出现这种情况呢？ 因为 setTimeout 是宏任务，由于 JS 单线程 EventLoop 机制，在主线同步任务执行完之后才会执行宏任务队列中的任务，因此在循环结束之后才会依次执行 setTimeout 的回调，但是输出 i 的函数作用域中没有定义变量 i，所以会到上层作用域中也就是全局作用域中进行查找，而此时全局作用域中的 i 已经递增到了 5，所以后面的 setTimeout 输出的就都是当前全局作用域的中 i 的值 5。怎样才能改造才能让函数正确输出 0、1、2、3、4 呢？ 解决办法：</p><ol><li>利用 setTimeout 函数的第三个参数。setTimeout 从第三个入参位置开始往后，可以传入无限个参数，这些参数会作为回调函数的附加参数存在。</li></ol><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span>\n    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token number">1000</span><span class="token punctuation">,</span>\n    i\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ol start="2"><li>在 setTimeout 外面再套一层函数，利用这个外部函数的入参来缓存每一个循环中的 i 值</li></ol><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">output</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">output</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ol start="3"><li>利用自执行函数的入参来缓存每一个循环中的 i 值</li></ol><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ol start="4"><li>利用 ES6 中的 let，通过生成块级作用域来固化 i 的值</li></ol><div class="language-js"><pre><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这里有个坑，就是如果函数的外面也输出一个 i 的话，那么我们只能使用前三种解决方案不能使用 let 解决方案，因为 let 解决方案生成的 i 是在块级作用域内的，在全局上下文中输出 i 无法找到块级作用域中的变量，会抛错。</p>',27);t.render=function(a,p,t,c,e,u){return n(),s("div",null,[o])};export default t;export{p as __pageData};
